[TOC]

#### 类的六个默认成员函数

如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数 。

```c++
//空类
class Date
{};
```



<img src="http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220513182050305.png" alt="image-20220513182050305" style="zoom:80%;" />



构造函数完成的是初始化工作，析构函数完成的是清理工作，拷贝构造就是拷贝，赋值重载也是拷贝，但是使用场景不一样，最后的取地址重载用的很少。

---

#### 构造函数

构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次。构造函数是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是**构造函数的主要任务并不是开空间创建对象，而是初始化对象**。  

---

**构造函数的特点**：

1. 函数名和类名相同。
2. 无返回值。
3. 对象实例化时自动调用对应的构造函数。
4. 构造函数可以重载

对象会调用对应的构造函数来进行初始化。

```c++
class A
{
public:
	//无参的构造函数
	A()
	{
		_a = 2;
	}

	//带参的构造函数
	A(int a)
	{
		_a = a;
	}
	void Print()
	{
		cout << _a << endl;
	}
private:
	int _a;
};

int main()
{
	A a1;
	A a2(10);
	a1.Print();
	a2.Print();
	return 0;
}
```

![image-20220513184141912](http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220513184141912.png)

这是类中写了构造函数来初始化，但是如果没有写构造函数呢？

**如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成** 。

```C++
class A
{
public:
	void Print()
	{
		cout << _a << endl;
	}
private:
	int _a;
};

int main()
{
	A a1;
	a1.Print();
	return 0;
}
```

<img src="http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220513184754070.png" alt="image-20220513184754070" style="zoom:80%;" />

对于这段代码，运行发现是输出随机值，那么编译器默认生成的构造函数是不是就没有什么用呢？

答案是不是的，看下一段代码就知道了。

```c++
class B
{
public:
    //类B的构造函数
	B()
	{
		_x = 1;
		_y = 2;
	}
private:
	int _x;
	int _y;
};

class A
{
public:

private:
	int _a;
    
    //类B定义的对象
	B _b;
};

int main()
{
	A a1;
	return 0;
}
```

<img src="http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220513185807780.png" alt="image-20220513185807780" style="zoom:67%;" />

通过调试可以观察到上面的初始化情况，可以发现_a没有初始化，但是对象 _b却被初始化了，这是为什么呢？

---

补充：这里需要补充一个关于类型的知识。**C++把类型分成内置类型(基本类型)和自定义类型**。内置类型就是语法已经定义好的类型：如`int/char...`，自定义类型就是我们使`class/struct/union`自己定义的类型。

---

**没有显示定义构造函数**

我们不写构造函数，编译器生成一个默认构造函数，在这里做了一个偏心的处理:

1. 内置类型不处理。
2. 自定义类型去调用它自己对应的构造函数。

---

补充：**无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数**， 并不是编译器默认生成的构造函数才叫默认构造函数。  

---

#### 析构函数

析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而**对象在销毁时会自动调用析构函数，完成类的一些资源清理工作**。

---

**析构函数的特点**：

1. 析构函数名是在类名前加上字符`~`。
2. 无参数无返回值。
3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。
4. **对象生命周期结束时，C++编译系统系统自动调用析构函数**。  

和构造函数一样都是自动调用，在对象生命周期结束时自动调用。那么析构函数有什么作用呢？一般的类好像没什么作用，但是像在stack这样的类中，会有动态开辟的空间，所以就需要在析构函数中去处理。

---

**没有显示定义析构函数**

析构函数和构造函数一样，不写析构函数，编译器生成一个默认的析构函数，编译器在这里也做了一个偏心的处理:

1. 内置类型不处理。
2. 自定义类型去调用它自己对应的析构函数。

---

#### 拷贝构造函数

拷贝构造函数是通过一个对象来创建一个对象，拷贝构造函数也是特殊的成员函数，其**特征**如下：

1. 拷贝构造函数**是构造函数的一个重载形式**。
2. 拷贝构造函数的**参数只有一个**且**必须使用引用传参**，使用**传值方式会引发无穷递归调用**。  

注意第二点拷贝构造函数在传参时要用引用，否则会引起无穷递归。

```c++
class A
{
public:
	A(int a)
	{
		_a = a;
	}
    //如果这里不是引用传参
	A(A a)
	{
		_a = a._a;
	}
private:
	int _a;
};
int main()
{
	A a1(10);
	A a2(a1);
	return 0;
}
```

<img src="http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220514195311803.png" alt="image-20220514195311803" style="zoom:67%;" />

**拷贝构造的无穷递归问题**

不用引用传参的话编译器会报错，因为这里会引起一个无穷递归的问题。

在实参传递形参时，这里其实就是一个拷贝，然后又去调用拷贝构造，同理，继续调用拷贝构造，就会引发一个无穷递归的错误，所以在这里需要使用引用来传参，防止无穷递归的发生。

**传参时最好加上const**

既然使用使用引用来传参，那么就要考虑到形参改变导致实参改变的问题，所以在使用引用时就最好要加一个const，防止出现实参的改变。对于const的使用，在传参时，不是做输出型参数时，最好都加上const，做保护。

---

**没有显示定义拷贝构造函数**

如果没有显示定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，编译器默认生成的拷贝构造函数和构造函数、析构函数不太一样。

1. 内置类型，进行字节序的**浅拷贝**(按字节序来拷贝，就像memcpy)。
2. 自定义类型去调用它自己对应的拷贝构造函数来完成拷贝。

---

##### 深浅拷贝

浅拷贝的缺点是很明显的，**浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**

![image-20220514213616501](http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220514213616501.png)

---

**浅拷贝的缺陷**

如果在成员变量中包含有一个指针，在构造函数中有一个动态开辟空间的操作，那么在析构函数中就会释放(free/delete)掉，这样就会出现同一块空间被释放两次的情况。

<img src="http://shixiaozhong.oss-cn-hangzhou.aliyuncs.com/img/image-20220514214531588.png" alt="image-20220514214531588" style="zoom: 67%;" />

在上图可以发现a1和a2指向的是同一块空间，a2先析构已经把_a指向的空间释放了，a1再析构就会将 _a所指向的空间再次释放，同一块空间进行两次释放，程序就会崩溃。所以对于这类问题，所以就需要进行深拷贝，开辟一块新空间。